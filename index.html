<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì‚¬ì§„ ì˜ë‹¨ì–´ ê°ê´€ì‹ í€´ì¦ˆ (Gemini+TTS)</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* ê°œì„ ëœ CSS ìŠ¤íƒ€ì¼ */
    :root {
      --primary: #6366f1;
      --primary-hover: #5855eb;
      --secondary: #f59e0b;
      --secondary-hover: #d97706;
      --success: #10b981;
      --success-hover: #059669;
      --danger: #ef4444;
      --danger-hover: #dc2626;
      --background: #fafaff;
      --surface: rgba(255, 255, 255, 0.9);
      --surface-hover: rgba(255, 255, 255, 0.95);
      --text: #1f2937;
      --text-muted: #6b7280;
      --border: #e5e7eb;
      --border-hover: #d1d5db;
      --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      --radius: 16px;
      --radius-sm: 8px;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--text);
      padding: 20px;
      line-height: 1.6;
    }
    .container {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 40px;
      box-shadow: var(--shadow-lg);
      max-width: 900px;
      width: 100%;
      text-align: center;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    h1 {
      color: var(--primary);
      margin-bottom: 16px;
      font-size: 2.5rem;
      font-weight: 700;
      letter-spacing: -0.025em;
    }
    h2 {
      color: var(--primary);
      margin-bottom: 24px;
      font-size: 2rem;
      font-weight: 600;
      letter-spacing: -0.025em;
    }
    h3 {
      color: var(--text);
      margin-bottom: 20px;
      font-size: 1.5rem;
      font-weight: 600;
    }
    .subtitle {
      color: var(--text-muted);
      margin-bottom: 32px;
      font-size: 1.125rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    .upload-area {
      border: 3px dashed var(--primary);
      border-radius: var(--radius);
      padding: 48px 24px;
      margin: 32px 0;
      background: rgba(99, 102, 241, 0.05);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .upload-area::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    .upload-area:hover {
      border-color: var(--primary-hover);
      background: rgba(99, 102, 241, 0.1);
      transform: translateY(-2px);
    }
    .upload-area.dragover {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
      transform: scale(1.02);
    }
    .upload-icon {
      font-size: 3rem;
      margin-bottom: 16px;
      opacity: 0.8;
    }
    .upload-text {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }
    .upload-hint {
      font-size: 0.875rem;
      color: var(--text-muted);
    }
    #fileInput {
      display: none;
    }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      margin: 8px;
      position: relative;
      overflow: hidden;
      text-decoration: none;
      display: inline-block;
    }
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.3s;
    }
    .btn:hover::before {
      left: 100%;
    }
    .btn-primary {
      background: var(--primary);
      color: white;
    }
    .btn-primary:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(99, 102, 241, 0.4);
    }
    .btn-secondary {
      background: var(--secondary);
      color: white;
    }
    .btn-secondary:hover {
      background: var(--secondary-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(245, 158, 11, 0.4);
    }
    .btn-success {
      background: var(--success);
      color: white;
    }
    .btn-success:hover {
      background: var(--success-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(16, 185, 129, 0.4);
    }
    .btn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
      opacity: 0.6;
    }
    .btn:disabled::before {
      display: none;
    }
    .loading {
      display: none;
      margin: 32px 0;
      padding: 24px;
      background: var(--surface-hover);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }
    .spinner {
      border: 4px solid #f3f4f6;
      border-top: 4px solid var(--primary);
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .image-preview {
      display: none;
      margin: 32px 0;
      padding: 24px;
      background: var(--surface-hover);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }
    .preview-img {
      max-width: 100%;
      max-height: 300px;
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow);
    }
    .word-extraction {
      display: none;
      margin: 32px 0;
      text-align: left;
    }
    .extracted-words {
      background: var(--surface-hover);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      padding: 24px;
      margin: 20px 0;
      max-height: 400px;
      overflow-y: auto;
    }
    .word-pair {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
      transition: background-color 0.2s;
    }
    .word-pair:hover {
      background: rgba(99, 102, 241, 0.05);
      border-radius: var(--radius-sm);
      margin: 0 -8px;
      padding: 12px 8px;
    }
    .word-pair:last-child {
      border-bottom: none;
    }
    .korean-word {
      font-weight: 600;
      color: var(--text);
    }
    .english-word {
      color: var(--primary);
      font-weight: 600;
    }
    .quiz-game {
      display: none;
    }
    .score-board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      margin-bottom: 32px;
      background: var(--surface-hover);
      padding: 20px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }
    .score-item {
      text-align: center;
      padding: 8px;
    }
    .score-label {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: 4px;
      font-weight: 500;
    }
    .score-value {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--primary);
    }
    .question-area {
      background: var(--surface-hover);
      padding: 32px;
      border-radius: var(--radius);
      margin-bottom: 32px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .question-type {
      font-size: 1.125rem;
      color: var(--primary);
      margin-bottom: 16px;
      font-weight: 600;
      padding: 8px 16px;
      background: rgba(99, 102, 241, 0.1);
      border-radius: 20px;
    }
    .question-word {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 16px;
    }
    .hint-area {
      margin: 24px 0;
      min-height: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .hint-image {
      max-width: 200px;
      max-height: 200px;
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow);
      margin: 16px 0;
    }
    .text-hint {
      padding: 16px 24px;
      background: rgba(245, 158, 11, 0.1);
      border-radius: var(--radius-sm);
      color: var(--secondary);
      font-weight: 600;
    }
    .pronounce-btn {
      background: var(--primary);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 600;
      font-size: 0.875rem;
      margin-left: 12px;
      transition: all 0.2s;
    }
    .pronounce-btn:hover {
      background: var(--primary-hover);
      transform: scale(1.05);
    }
    .options-area {
      margin: 32px 0;
      width: 100%;
      display: grid;
      gap: 12px;
    }
    .option {
      background: white;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px 20px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 1.125rem;
      text-align: left;
      font-weight: 500;
    }
    .option:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }
    .option.selected {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
      color: var(--primary);
    }
    .option.correct {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }
    .option.incorrect {
      border-color: var(--danger);
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }
    .option.disabled {
      cursor: not-allowed;
      opacity: 0.7;
    }
    .feedback {
      margin: 24px 0;
      padding: 20px;
      border-radius: var(--radius-sm);
      font-weight: 600;
      font-size: 1.125rem;
      display: none;
      border: 2px solid;
    }
    .feedback.correct {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
      border-color: var(--success);
    }
    .feedback.incorrect {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border-color: var(--danger);
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      margin: 24px 0;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 4px;
    }
    .game-over {
      display: none;
      background: rgba(245, 158, 11, 0.1);
      padding: 32px;
      border-radius: var(--radius);
      border: 2px solid var(--secondary);
      margin-top: 32px;
    }
    .final-score {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--secondary);
      margin-bottom: 20px;
    }
    .error-message {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      padding: 20px;
      border-radius: var(--radius-sm);
      border: 2px solid var(--danger);
      margin: 24px 0;
      display: none;
      font-weight: 500;
    }
    .button-area {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 24px 0;
    }
    .hint-loading {
      width: 32px;
      height: 32px;
      border: 4px solid #f3f4f6;
      border-top: 4px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    /* ë°˜ì‘í˜• ë””ìì¸ */
    @media (max-width: 768px) {
      .container {
        padding: 24px;
        margin: 10px;
      }
      h1 {
        font-size: 2rem;
      }
      h2 {
        font-size: 1.75rem;
      }
      .upload-area {
        padding: 32px 16px;
      }
      .score-board {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .word-pair {
        flex-direction: column;
        gap: 8px;
        text-align: center;
      }
      .question-word {
        font-size: 2rem;
      }
      .question-area {
        padding: 24px 16px;
      }
      .button-area {
        flex-direction: column;
      }
      .btn {
        width: 100%;
        margin: 6px 0;
      }
      .option {
        font-size: 1rem;
      }
    }
    /* ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    .container > * {
      animation: fadeIn 0.6s ease-out;
    }
    .word-pair {
      animation: slideIn 0.4s ease-out;
    }
    .option {
      animation: fadeIn 0.3s ease-out;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="uploadScreen">
      <h1>ğŸ“¸ ì˜ì–´ ì‚¬ì§„ ë‹¨ì–´ í€´ì¦ˆ</h1>
      <p class="subtitle">ì˜ì–´ ë‹¨ì–´ ì‚¬ì§„ì„ ì˜¬ë¦¬ë©´<br>ëœ», ë°œìŒ, ê·¸ë¦¼íŒíŠ¸ê¹Œì§€ ìë™ í€´ì¦ˆë¡œ ë‚˜ì˜µë‹ˆë‹¤!</p>
      <div class="upload-area" id="uploadArea" tabindex="0">
        <div class="upload-icon">ğŸ“</div>
        <div class="upload-text">ì—¬ê¸°ë¥¼ í´ë¦­í•˜ê±°ë‚˜ íŒŒì¼ì„ ë“œë˜ê·¸í•˜ì„¸ìš”</div>
        <div class="upload-hint">JPG, PNG, GIF íŒŒì¼ ì§€ì›</div>
      </div>
      <input type="file" id="fileInput" accept="image/*" />
      <button class="btn btn-primary" onclick="fileInput.click()">ğŸ“· ì‚¬ì§„ ì„ íƒí•˜ê¸°</button>
      <div class="loading" id="loading">
        <div class="spinner"></div>
        <p id="loadingMsg">ì´ë¯¸ì§€ë¥¼ ë¶„ì„ ì¤‘...</p>
      </div>
      <div class="error-message" id="errorMessage"></div>
    </div>
    <div class="image-preview" id="imagePreview">
      <h3>ì—…ë¡œë“œëœ ì´ë¯¸ì§€</h3>
      <img id="previewImg" class="preview-img" alt="ë¯¸ë¦¬ë³´ê¸°" />
    </div>
    <div class="word-extraction" id="wordExtraction">
      <h3>ğŸ“ ì¶”ì¶œëœ ë‹¨ì–´ë“¤ (<span id="wordCount">0</span>ê°œ)</h3>
      <div class="extracted-words" id="extractedWords"></div>
      <div style="text-align: center; margin-top: 24px;">
        <button class="btn btn-success" id="startQuizBtn">ğŸ¯ ê°ê´€ì‹ í€´ì¦ˆ ì‹œì‘í•˜ê¸°</button>
        <button class="btn btn-secondary" onclick="resetApp()">ğŸ”„ ë‹¤ë¥¸ ì‚¬ì§„ ì—…ë¡œë“œ</button>
      </div>
    </div>
    <div class="quiz-game" id="quizGame">
      <h2>ğŸ® ì˜ë‹¨ì–´ ê°ê´€ì‹ í€´ì¦ˆ</h2>
      <div class="score-board">
        <div class="score-item">
          <div class="score-label">í˜„ì¬ ë¬¸ì œ</div>
          <div class="score-value" id="currentQuestion">1</div>
        </div>
        <div class="score-item">
          <div class="score-label">ì´ ë¬¸ì œ</div>
          <div class="score-value" id="totalQuestions">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ì ìˆ˜</div>
          <div class="score-value" id="score">0</div>
        </div>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="question-area" id="questionArea">
        <div class="question-type" id="questionType">ğŸ‡¬ğŸ‡§ ì˜ì–´ â†’ í•œêµ­ì–´</div>
        <div style="display:flex; align-items:center; justify-content:center;">
          <div class="question-word" id="questionWord">ë‹¨ì–´</div>
          <button class="pronounce-btn" title="ë°œìŒ ë“£ê¸°" id="pronounceBtn">ğŸ”Š</button>
        </div>
        <div class="hint-area" id="hintArea"></div>
      </div>
      <div class="options-area" id="optionsArea"></div>
      <div class="button-area">
        <button class="btn btn-secondary" id="hintBtn">ğŸ–¼ï¸ ê·¸ë¦¼ íŒíŠ¸</button>
        <button class="btn btn-primary" id="submitBtn" disabled>âœ… ì •ë‹µ ì œì¶œ</button>
        <button class="btn btn-success" id="nextBtn" style="display:none;">â¡ï¸ ë‹¤ìŒ ë¬¸ì œ</button>
      </div>
      <div class="feedback" id="feedback"></div>
      <div class="game-over" id="gameOver">
        <div class="final-score" id="finalScore"></div>
        <button class="btn btn-primary" onclick="restartQuiz()">ğŸ”„ í€´ì¦ˆ ë‹¤ì‹œí•˜ê¸°</button>
        <button class="btn btn-secondary" onclick="resetApp()">ğŸ“· ìƒˆ ì‚¬ì§„ ì—…ë¡œë“œ</button>
      </div>
    </div>
  </div>
  <script>
    // ** ë³€ê²½ëœ API URL ì„¤ì • (í”„ë¡ì‹œ ì„œë²„ ì‚¬ìš©) **
    // TODO: ì•„ë˜ YOUR_WORKER_URL ë¶€ë¶„ì„ ì‹¤ì œ Cloudflare Worker ì£¼ì†Œë¡œ ë³€ê²½í•´ì£¼ì„¸ìš”.
    const WORKER_URL = 'https://wordquiz.dfkimni.workers.dev/';
    const PROXY_URL = `${WORKER_URL}/api`;

    // API í˜¸ì¶œì„ ìœ„í•œ ì¬ì‹œë„ ë¡œì§
    async function fetchWithRetry(url, options, maxRetries = 3) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            throw new Error('API ì‘ë‹µ ì‹¤íŒ¨: ' + response.statusText);
          }
          return response;
        } catch (error) {
          console.error('API í˜¸ì¶œ ì‹¤íŒ¨ (ì¬ì‹œë„ ì¤‘):', error);
          const delay = Math.pow(2, i) * 1000;
          await new Promise(res => setTimeout(res, delay));
        }
      }
      throw new Error('ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼. API í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }

    let extractedWords = [];
    let quizQuestions = [];
    let currentQuestionIndex = 0;
    let score = 0;
    let selectedOption = null;
    let isAnswered = false;
    let hintUsed = false;
    let answerScore = 100;
    let hintImageUrl = null;

    // DOM ìš”ì†Œ ìºì‹±
    const uploadArea = document.getElementById("uploadArea");
    const fileInput = document.getElementById("fileInput");
    const loading = document.getElementById("loading");
    const loadingMsg = document.getElementById("loadingMsg");
    const errorMessage = document.getElementById("errorMessage");
    const uploadScreen = document.getElementById("uploadScreen");
    const imagePreview = document.getElementById("imagePreview");
    const previewImg = document.getElementById("previewImg");
    const wordExtraction = document.getElementById("wordExtraction");
    const extractedWordsEl = document.getElementById("extractedWords");
    const wordCount = document.getElementById("wordCount");
    const startQuizBtn = document.getElementById("startQuizBtn");
    const quizGame = document.getElementById("quizGame");
    const questionType = document.getElementById("questionType");
    const questionWord = document.getElementById("questionWord");
    const hintArea = document.getElementById("hintArea");
    const optionsArea = document.getElementById("optionsArea");
    const hintBtn = document.getElementById("hintBtn");
    const submitBtn = document.getElementById("submitBtn");
    const nextBtn = document.getElementById("nextBtn");
    const feedback = document.getElementById("feedback");
    const scoreEl = document.getElementById("score");
    const currentQuestionEl = document.getElementById("currentQuestion");
    const totalQuestionsEl = document.getElementById("totalQuestions");
    const progressFill = document.getElementById("progressFill");
    const gameOver = document.getElementById("gameOver");
    const finalScore = document.getElementById("finalScore");
    const pronounceBtn = document.getElementById("pronounceBtn");

    // ì—…ë¡œë“œ ì´ë²¤íŠ¸
    uploadArea.addEventListener("click", () => fileInput.click());
    uploadArea.addEventListener("dragover", e => { e.preventDefault(); uploadArea.classList.add("dragover"); });
    uploadArea.addEventListener("dragleave", e => { e.preventDefault(); uploadArea.classList.remove("dragover"); });
    uploadArea.addEventListener("drop", e => { e.preventDefault(); uploadArea.classList.remove("dragover"); if (e.dataTransfer.files.length > 0) processFile(e.dataTransfer.files[0]); });
    fileInput.addEventListener("change", e => { if (e.target.files.length > 0) processFile(e.target.files[0]); });

    // ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
    startQuizBtn.addEventListener('click', startQuiz);
    hintBtn.addEventListener('click', showHint);
    submitBtn.addEventListener('click', submitAnswer);
    nextBtn.addEventListener('click', nextQuestion);
    pronounceBtn.addEventListener('click', pronounceWord);

    // ì‚¬ì§„ íŒŒì¼ ì²˜ë¦¬: OCR ì‹¤í–‰ â†’ ë‹¨ì–´ ì¶”ì¶œ â†’ Gemini API ë²ˆì—­ ìš”ì²­
    async function processFile(file) {
      if (!file.type.startsWith("image/")) {
        showError("ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
        return;
      }
      previewImg.src = "";
      imagePreview.style.display = "none";
      loading.style.display = "block";
      errorMessage.style.display = "none";
      loadingMsg.textContent = "ì‚¬ì§„ì—ì„œ ì˜ì–´ ë‹¨ì–´ ì¶”ì¶œ ì¤‘...";
      const reader = new FileReader();
      reader.onload = e => {
        previewImg.src = e.target.result;
        imagePreview.style.display = "block";
      };
      reader.readAsDataURL(file);
      try {
        const ocrRes = await Tesseract.recognize(file, "eng", {
          logger: m => { if (m.status === "recognizing text") loadingMsg.textContent = `ë‹¨ì–´ ì¶”ì¶œ ì¤‘... ${Math.round(m.progress * 100)}%`; }
        });
        const wordsRaw = ocrRes.data.words.map(w => w.text).join(' ').split(/\W+/);
        const wordsSet = new Set(wordsRaw.map(w => w.trim().toLowerCase()).filter(w => /^[a-zA-Z]{3,15}$/.test(w)));
        const words = [...wordsSet].slice(0, 20);
        if (words.length < 4) throw new Error("í€´ì¦ˆë¥¼ ë§Œë“¤ ì¶©ë¶„í•œ ë‹¨ì–´(ìµœì†Œ 4ê°œ)ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
        loadingMsg.textContent = "ë²ˆì—­ ì¤‘...";
        extractedWords = await translateWordsWithGemini(words);
        if (extractedWords.length < 4) throw new Error("ë²ˆì—­ ê²°ê³¼ ì´ìƒ: í€´ì¦ˆë¥¼ ë§Œë“¤ ì¶©ë¶„í•œ ë‹¨ì–´ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
        loading.style.display = "none";
        displayExtractedWords();
      } catch (e) {
        console.error(e);
        showError("OCR ë˜ëŠ” ë²ˆì—­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message);
        loading.style.display = "none";
      }
    }

    // Gemini APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ì–´ ë‹¨ì–´ë¥¼ í•œêµ­ì–´ë¡œ ë²ˆì—­í•˜ëŠ” í•¨ìˆ˜
    async function translateWordsWithGemini(words) {
      const chatHistory = [{
        role: "user",
        parts: [{
          text: `ë‹¤ìŒ ì˜ì–´ ë‹¨ì–´ë“¤ì„ í•œêµ­ì–´ë¡œ ë²ˆì—­í•˜ê³ , ê° ë‹¨ì–´ì— ëŒ€í•´ ì˜ì–´ ë‹¨ì–´ì™€ í•œêµ­ì–´ ë²ˆì—­ì„ í¬í•¨í•˜ëŠ” JSON ë°°ì—´ì„ ìƒì„±í•´ì¤˜. JSONì˜ í‚¤ëŠ” 'englishWord'ì™€ 'koreanTranslation'ìœ¼ë¡œ í•´ì¤˜. JSON í˜•ì‹ ì™¸ì—ëŠ” ì–´ë–¤ ë‹¤ë¥¸ í…ìŠ¤íŠ¸ë‚˜ ì„¤ëª…ë„ ì¶”ê°€í•˜ì§€ ë§ˆ.
          ì˜ˆì‹œ:
          input: ["apple", "banana"]
          output: [{"englishWord": "apple", "koreanTranslation": "ì‚¬ê³¼"}, {"englishWord": "banana", "koreanTranslation": "ë°”ë‚˜ë‚˜"}]
          ë‹¨ì–´ ëª©ë¡: [${words.map(w => `"${w}"`).join(', ')}]
          `
        }]
      }];
      const payload = {
        contents: chatHistory,
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: {
            type: "ARRAY",
            items: {
              type: "OBJECT",
              properties: {
                "englishWord": { "type": "STRING" },
                "koreanTranslation": { "type": "STRING" }
              },
              "propertyOrdering": ["englishWord", "koreanTranslation"]
            }
          }
        }
      };
      try {
        const response = await fetchWithRetry(`${PROXY_URL}/translate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (result.candidates && result.candidates.length > 0) {
          const jsonString = result.candidates[0].content.parts[0].text;
          const parsedJson = JSON.parse(jsonString);
          return parsedJson.filter(item => item.koreanTranslation);
        } else {
          return [];
        }
      } catch (e) {
        console.error("Translation API error:", e);
        throw new Error("ë‹¨ì–´ ë²ˆì—­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    }

    // ì¶”ì¶œëœ ë‹¨ì–´ ëª©ë¡ì„ í™”ë©´ì— í‘œì‹œ
    function displayExtractedWords() {
      uploadScreen.style.display = 'none';
      wordExtraction.style.display = 'block';
      wordCount.textContent = extractedWords.length;
      extractedWordsEl.innerHTML = '';
      extractedWords.forEach(wordPair => {
        const div = document.createElement('div');
        div.className = 'word-pair';
        div.innerHTML = `<span class="korean-word">${wordPair.koreanTranslation}</span><span class="english-word">${wordPair.englishWord}</span>`;
        extractedWordsEl.appendChild(div);
      });
    }

    // í€´ì¦ˆ ì‹œì‘
    function startQuiz() {
      wordExtraction.style.display = 'none';
      quizGame.style.display = 'block';
      quizQuestions = shuffleArray([...extractedWords]); // ë‹¨ì–´ ëª©ë¡ì„ ì„ì–´ì„œ í€´ì¦ˆ ë¬¸ì œë¡œ ì‚¬ìš©
      currentQuestionIndex = 0;
      score = 0;
      updateScoreBoard();
      updateProgressBar();
      showQuestion();
    }

    // í€´ì¦ˆ ë‹¤ì‹œ ì‹œì‘
    function restartQuiz() {
      gameOver.style.display = 'none';
      startQuiz();
    }

    // í€´ì¦ˆ ë¬¸ì œ í‘œì‹œ
    function showQuestion() {
      // ìƒíƒœ ì´ˆê¸°í™”
      selectedOption = null;
      isAnswered = false;
      hintUsed = false;
      answerScore = 100;
      hintImageUrl = null;
      feedback.style.display = 'none';
      hintArea.innerHTML = '';
      submitBtn.style.display = 'inline-block';
      submitBtn.disabled = true;
      nextBtn.style.display = 'none';
      hintBtn.disabled = false;

      if (currentQuestionIndex >= quizQuestions.length) {
        // ëª¨ë“  ë¬¸ì œ í’€ì´ ì™„ë£Œ
        endQuiz();
        return;
      }

      const question = quizQuestions[currentQuestionIndex];
      questionWord.textContent = question.englishWord;
      updateScoreBoard();

      // ê°ê´€ì‹ ì˜µì…˜ ìƒì„±
      createOptions(question);
    }

    // ê°ê´€ì‹ ì˜µì…˜ ìƒì„±
    function createOptions(question) {
      optionsArea.innerHTML = '';
      const allWords = [...extractedWords];
      // ì •ë‹µì„ ì œì™¸í•œ ë‹¤ë¥¸ ë‹¨ì–´ë“¤ì„ í›„ë³´ë¡œ ì‚¬ìš©
      const incorrectOptions = allWords.filter(item => item.englishWord !== question.englishWord);
      const shuffledIncorrect = shuffleArray(incorrectOptions);
      // ì •ë‹µ + ì˜¤ë‹µ 3ê°œ
      const options = [
        question.koreanTranslation,
        shuffledIncorrect[0].koreanTranslation,
        shuffledIncorrect[1].koreanTranslation,
        shuffledIncorrect[2].koreanTranslation
      ];
      const shuffledOptions = shuffleArray(options);

      shuffledOptions.forEach(optionText => {
        const option = document.createElement('div');
        option.className = 'option';
        option.textContent = optionText;
        option.addEventListener('click', () => handleOptionClick(option, optionText));
        optionsArea.appendChild(option);
      });
    }

    // ì˜µì…˜ í´ë¦­ í•¸ë“¤ëŸ¬
    function handleOptionClick(optionEl, optionText) {
      if (isAnswered) return;
      // ì´ì „ì— ì„ íƒëœ ì˜µì…˜ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
      document.querySelectorAll('.option').forEach(el => el.classList.remove('selected'));
      // í˜„ì¬ ì„ íƒëœ ì˜µì…˜ ìŠ¤íƒ€ì¼ ì ìš©
      optionEl.classList.add('selected');
      selectedOption = optionText;
      submitBtn.disabled = false;
    }

    // ì •ë‹µ ì œì¶œ
    function submitAnswer() {
      if (!selectedOption || isAnswered) return;
      isAnswered = true;
      submitBtn.disabled = true;
      nextBtn.style.display = 'inline-block';
      hintBtn.disabled = true;

      const question = quizQuestions[currentQuestionIndex];
      const correctOption = question.koreanTranslation;

      document.querySelectorAll('.option').forEach(el => {
        el.classList.add('disabled');
        if (el.textContent === correctOption) {
          el.classList.add('correct');
        } else if (el.textContent === selectedOption) {
          el.classList.add('incorrect');
        }
      });

      if (selectedOption === correctOption) {
        feedback.textContent = `âœ… ì •ë‹µì…ë‹ˆë‹¤! (+${answerScore}ì )`;
        feedback.className = 'feedback correct';
        score += answerScore;
      } else {
        feedback.textContent = `âŒ ì˜¤ë‹µì…ë‹ˆë‹¤. ì •ë‹µì€ '${correctOption}' ì´ì—ˆì–´ìš”.`;
        feedback.className = 'feedback incorrect';
        score = Math.max(0, score - 50); // ì˜¤ë‹µ ì‹œ ê°ì 
      }
      feedback.style.display = 'block';
      updateScoreBoard();
    }

    // ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™
    function nextQuestion() {
      currentQuestionIndex++;
      updateProgressBar();
      showQuestion();
    }

    // í€´ì¦ˆ ì¢…ë£Œ
    function endQuiz() {
      quizGame.style.display = 'none';
      gameOver.style.display = 'block';
      finalScore.textContent = `ìµœì¢… ì ìˆ˜: ${score}ì `;
    }

    // ê·¸ë¦¼ íŒíŠ¸ ì œê³µ
    async function showHint() {
      if (hintUsed) return;
      hintUsed = true;
      answerScore -= 30; // íŒíŠ¸ ì‚¬ìš© ì‹œ ê°ì 
      hintBtn.disabled = true;

      const question = quizQuestions[currentQuestionIndex];
      hintArea.innerHTML = `<div class="hint-loading"></div>`;

      try {
        const payload = {
          instances: {
            prompt: `a line art drawing of "${question.englishWord}"`
          },
          parameters: { "sampleCount": 1 }
        };
        const response = await fetchWithRetry(`${PROXY_URL}/image`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
          hintImageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
          hintArea.innerHTML = `<img src="${hintImageUrl}" alt="ê·¸ë¦¼ íŒíŠ¸" class="hint-image" />`;
        } else {
          hintArea.innerHTML = `<div class="text-hint">ê·¸ë¦¼ íŒíŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>`;
        }
      } catch (e) {
        console.error("Image API error:", e);
        hintArea.innerHTML = `<div class="text-hint">ê·¸ë¦¼ íŒíŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ</div>`;
      }
    }

    // ë‹¨ì–´ ë°œìŒ ë“£ê¸°
    async function pronounceWord() {
      const question = quizQuestions[currentQuestionIndex];
      const audioBtn = pronounceBtn;
      audioBtn.disabled = true;
      audioBtn.innerHTML = 'ğŸ§';

      try {
        const payload = {
          contents: [{
            parts: [{ text: `Say in an even tone: ${question.englishWord}` }]
          }],
          generationConfig: {
            responseModalities: ["AUDIO"],
            speechConfig: {
              voiceConfig: {
                prebuiltVoiceConfig: { voiceName: "Iapetus" }
              }
            }
          },
          model: "gemini-2.5-flash-preview-tts"
        };
        const response = await fetchWithRetry(`${PROXY_URL}/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        const part = result?.candidates?.[0]?.content?.parts?.[0];
        const audioData = part?.inlineData?.data;
        const mimeType = part?.inlineData?.mimeType;

        if (audioData && mimeType && mimeType.startsWith("audio/")) {
          const sampleRate = 24000;
          const pcmData = base64ToArrayBuffer(audioData);
          const pcm16 = new Int16Array(pcmData);
          const wavBlob = pcmToWav(pcm16, sampleRate);
          const audioUrl = URL.createObjectURL(wavBlob);
          const audio = new Audio(audioUrl);
          audio.play();
        } else {
          console.error("TTS API ì‘ë‹µ ì˜¤ë¥˜");
        }
      } catch (e) {
        console.error("TTS API error:", e);
      } finally {
        audioBtn.disabled = false;
        audioBtn.innerHTML = 'ğŸ”Š';
      }
    }

    // ìŠ¤ì½”ì–´ë³´ë“œ ì—…ë°ì´íŠ¸
    function updateScoreBoard() {
      currentQuestionEl.textContent = currentQuestionIndex + 1;
      totalQuestionsEl.textContent = quizQuestions.length;
      scoreEl.textContent = score;
    }

    // ì§„í–‰ ë°” ì—…ë°ì´íŠ¸
    function updateProgressBar() {
      const progress = ((currentQuestionIndex + 1) / quizQuestions.length) * 100;
      progressFill.style.width = `${progress}%`;
    }

    // ì „ì²´ ì•± ì´ˆê¸°í™”
    function resetApp() {
      location.reload();
    }

    // ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
    function showError(msg) {
      errorMessage.textContent = msg;
      errorMessage.style.display = 'block';
    }

    // ë°°ì—´ ì„ê¸° (Fisher-Yates ì•Œê³ ë¦¬ì¦˜)
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Base64 ë¬¸ìì—´ì„ ArrayBufferë¡œ ë³€í™˜
    function base64ToArrayBuffer(base64) {
      const binaryString = window.atob(base64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    // PCM ì˜¤ë””ì˜¤ ë°ì´í„°ë¥¼ WAV Blobìœ¼ë¡œ ë³€í™˜
    function pcmToWav(pcm16, sampleRate) {
      const numChannels = 1;
      const bitDepth = 16;
      const buffer = new ArrayBuffer(44 + pcm16.length * 2);
      const view = new DataView(buffer);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      // RIFF identifier
      writeString(view, 0, 'RIFF');
      // RIFF chunk length
      view.setUint32(4, 36 + pcm16.length * 2, true);
      // RIFF type
      writeString(view, 8, 'WAVE');
      // format chunk identifier
      writeString(view, 12, 'fmt ');
      // format chunk length
      view.setUint32(16, 16, true);
      // sample format (1 = PCM)
      view.setUint16(20, 1, true);
      // number of channels
      view.setUint16(22, numChannels, true);
      // sample rate
      view.setUint32(24, sampleRate, true);
      // byte rate
      view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
      // block align
      view.setUint16(32, numChannels * (bitDepth / 8), true);
      // bits per sample
      view.setUint16(34, bitDepth, true);
      // data chunk identifier
      writeString(view, 36, 'data');
      // data chunk length
      view.setUint32(40, pcm16.length * 2, true);

      // PCM audio data
      let offset = 44;
      for (let i = 0; i < pcm16.length; i++, offset += 2) {
        view.setInt16(offset, pcm16[i], true);
      }

      return new Blob([view], { type: 'audio/wav' });
    }
  </script>
</body>
</html>
