<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>사진 영단어 객관식 퀴즈 (Gemini+TTS)</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 개선된 CSS 스타일 */
    :root {
      --primary: #6366f1;
      --primary-hover: #5855eb;
      --secondary: #f59e0b;
      --secondary-hover: #d97706;
      --success: #10b981;
      --success-hover: #059669;
      --danger: #ef4444;
      --danger-hover: #dc2626;
      --background: #fafaff;
      --surface: rgba(255, 255, 255, 0.9);
      --surface-hover: rgba(255, 255, 255, 0.95);
      --text: #1f2937;
      --text-muted: #6b7280;
      --border: #e5e7eb;
      --border-hover: #d1d5db;
      --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      --radius: 16px;
      --radius-sm: 8px;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--text);
      padding: 20px;
      line-height: 1.6;
    }
    .container {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 40px;
      box-shadow: var(--shadow-lg);
      max-width: 900px;
      width: 100%;
      text-align: center;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    h1 {
      color: var(--primary);
      margin-bottom: 16px;
      font-size: 2.5rem;
      font-weight: 700;
      letter-spacing: -0.025em;
    }
    h2 {
      color: var(--primary);
      margin-bottom: 24px;
      font-size: 2rem;
      font-weight: 600;
      letter-spacing: -0.025em;
    }
    h3 {
      color: var(--text);
      margin-bottom: 20px;
      font-size: 1.5rem;
      font-weight: 600;
    }
    .subtitle {
      color: var(--text-muted);
      margin-bottom: 32px;
      font-size: 1.125rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    .upload-area {
      border: 3px dashed var(--primary);
      border-radius: var(--radius);
      padding: 48px 24px;
      margin: 32px 0;
      background: rgba(99, 102, 241, 0.05);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .upload-area::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    .upload-area:hover {
      border-color: var(--primary-hover);
      background: rgba(99, 102, 241, 0.1);
      transform: translateY(-2px);
    }
    .upload-area.dragover {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
      transform: scale(1.02);
    }
    .upload-icon {
      font-size: 3rem;
      margin-bottom: 16px;
      opacity: 0.8;
    }
    .upload-text {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }
    .upload-hint {
      font-size: 0.875rem;
      color: var(--text-muted);
    }
    #fileInput {
      display: none;
    }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      margin: 8px;
      position: relative;
      overflow: hidden;
      text-decoration: none;
      display: inline-block;
    }
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.3s;
    }
    .btn:hover::before {
      left: 100%;
    }
    .btn-primary {
      background: var(--primary);
      color: white;
    }
    .btn-primary:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(99, 102, 241, 0.4);
    }
    .btn-secondary {
      background: var(--secondary);
      color: white;
    }
    .btn-secondary:hover {
      background: var(--secondary-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(245, 158, 11, 0.4);
    }
    .btn-success {
      background: var(--success);
      color: white;
    }
    .btn-success:hover {
      background: var(--success-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 25px -5px rgba(16, 185, 129, 0.4);
    }
    .btn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
      opacity: 0.6;
    }
    .btn:disabled::before {
      display: none;
    }
    .loading {
      display: none;
      margin: 32px 0;
      padding: 24px;
      background: var(--surface-hover);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }
    .spinner {
      border: 4px solid #f3f4f6;
      border-top: 4px solid var(--primary);
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .image-preview {
      display: none;
      margin: 32px 0;
      padding: 24px;
      background: var(--surface-hover);
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }
    .preview-img {
      max-width: 100%;
      max-height: 300px;
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow);
    }
    .word-extraction {
      display: none;
      margin: 32px 0;
      text-align: left;
    }
    .extracted-words {
      background: var(--surface-hover);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      padding: 24px;
      margin: 20px 0;
      max-height: 400px;
      overflow-y: auto;
    }
    .word-pair {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
      transition: background-color 0.2s;
    }
    .word-pair:hover {
      background: rgba(99, 102, 241, 0.05);
      border-radius: var(--radius-sm);
      margin: 0 -8px;
      padding: 12px 8px;
    }
    .word-pair:last-child {
      border-bottom: none;
    }
    .korean-word {
      font-weight: 600;
      color: var(--text);
    }
    .english-word {
      color: var(--primary);
      font-weight: 600;
    }
    .quiz-game {
      display: none;
    }
    .score-board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      margin-bottom: 32px;
      background: var(--surface-hover);
      padding: 20px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
    }
    .score-item {
      text-align: center;
      padding: 8px;
    }
    .score-label {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: 4px;
      font-weight: 500;
    }
    .score-value {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--primary);
    }
    .question-area {
      background: var(--surface-hover);
      padding: 32px;
      border-radius: var(--radius);
      margin-bottom: 32px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .question-type {
      font-size: 1.125rem;
      color: var(--primary);
      margin-bottom: 16px;
      font-weight: 600;
      padding: 8px 16px;
      background: rgba(99, 102, 241, 0.1);
      border-radius: 20px;
    }
    .question-word {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 16px;
    }
    .hint-area {
      margin: 24px 0;
      min-height: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .hint-image {
      max-width: 200px;
      max-height: 200px;
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow);
      margin: 16px 0;
    }
    .text-hint {
      padding: 16px 24px;
      background: rgba(245, 158, 11, 0.1);
      border-radius: var(--radius-sm);
      color: var(--secondary);
      font-weight: 600;
    }
    .pronounce-btn {
      background: var(--primary);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 600;
      font-size: 0.875rem;
      margin-left: 12px;
      transition: all 0.2s;
    }
    .pronounce-btn:hover {
      background: var(--primary-hover);
      transform: scale(1.05);
    }
    .options-area {
      margin: 32px 0;
      width: 100%;
      display: grid;
      gap: 12px;
    }
    .option {
      background: white;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px 20px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 1.125rem;
      text-align: left;
      font-weight: 500;
    }
    .option:hover {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }
    .option.selected {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
      color: var(--primary);
    }
    .option.correct {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }
    .option.incorrect {
      border-color: var(--danger);
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }
    .option.disabled {
      cursor: not-allowed;
      opacity: 0.7;
    }
    .feedback {
      margin: 24px 0;
      padding: 20px;
      border-radius: var(--radius-sm);
      font-weight: 600;
      font-size: 1.125rem;
      display: none;
      border: 2px solid;
    }
    .feedback.correct {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
      border-color: var(--success);
    }
    .feedback.incorrect {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border-color: var(--danger);
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      margin: 24px 0;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 4px;
    }
    .game-over {
      display: none;
      background: rgba(245, 158, 11, 0.1);
      padding: 32px;
      border-radius: var(--radius);
      border: 2px solid var(--secondary);
      margin-top: 32px;
    }
    .final-score {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--secondary);
      margin-bottom: 20px;
    }
    .error-message {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      padding: 20px;
      border-radius: var(--radius-sm);
      border: 2px solid var(--danger);
      margin: 24px 0;
      display: none;
      font-weight: 500;
    }
    .button-area {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 24px 0;
    }
    .hint-loading {
      width: 32px;
      height: 32px;
      border: 4px solid #f3f4f6;
      border-top: 4px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    /* 반응형 디자인 */
    @media (max-width: 768px) {
      .container {
        padding: 24px;
        margin: 10px;
      }
      h1 {
        font-size: 2rem;
      }
      h2 {
        font-size: 1.75rem;
      }
      .upload-area {
        padding: 32px 16px;
      }
      .score-board {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .word-pair {
        flex-direction: column;
        gap: 8px;
        text-align: center;
      }
      .question-word {
        font-size: 2rem;
      }
      .question-area {
        padding: 24px 16px;
      }
      .button-area {
        flex-direction: column;
      }
      .btn {
        width: 100%;
        margin: 6px 0;
      }
      .option {
        font-size: 1rem;
      }
    }
    /* 애니메이션 */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    .container > * {
      animation: fadeIn 0.6s ease-out;
    }
    .word-pair {
      animation: slideIn 0.4s ease-out;
    }
    .option {
      animation: fadeIn 0.3s ease-out;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="uploadScreen">
      <h1>📸 영어 사진 단어 퀴즈</h1>
      <p class="subtitle">영어 단어 사진을 올리면<br>뜻, 발음, 그림힌트까지 자동 퀴즈로 나옵니다!</p>
      <div class="upload-area" id="uploadArea" tabindex="0">
        <div class="upload-icon">📁</div>
        <div class="upload-text">여기를 클릭하거나 파일을 드래그하세요</div>
        <div class="upload-hint">JPG, PNG, GIF 파일 지원</div>
      </div>
      <input type="file" id="fileInput" accept="image/*" />
      <button class="btn btn-primary" onclick="fileInput.click()">📷 사진 선택하기</button>
      <div class="loading" id="loading">
        <div class="spinner"></div>
        <p id="loadingMsg">이미지를 분석 중...</p>
      </div>
      <div class="error-message" id="errorMessage"></div>
    </div>
    <div class="image-preview" id="imagePreview">
      <h3>업로드된 이미지</h3>
      <img id="previewImg" class="preview-img" alt="미리보기" />
    </div>
    <div class="word-extraction" id="wordExtraction">
      <h3>📝 추출된 단어들 (<span id="wordCount">0</span>개)</h3>
      <div class="extracted-words" id="extractedWords"></div>
      <div style="text-align: center; margin-top: 24px;">
        <button class="btn btn-success" id="startQuizBtn">🎯 객관식 퀴즈 시작하기</button>
        <button class="btn btn-secondary" onclick="resetApp()">🔄 다른 사진 업로드</button>
      </div>
    </div>
    <div class="quiz-game" id="quizGame">
      <h2>🎮 영단어 객관식 퀴즈</h2>
      <div class="score-board">
        <div class="score-item">
          <div class="score-label">현재 문제</div>
          <div class="score-value" id="currentQuestion">1</div>
        </div>
        <div class="score-item">
          <div class="score-label">총 문제</div>
          <div class="score-value" id="totalQuestions">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">점수</div>
          <div class="score-value" id="score">0</div>
        </div>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="question-area" id="questionArea">
        <div class="question-type" id="questionType">🇬🇧 영어 → 한국어</div>
        <div style="display:flex; align-items:center; justify-content:center;">
          <div class="question-word" id="questionWord">단어</div>
          <button class="pronounce-btn" title="발음 듣기" id="pronounceBtn">🔊</button>
        </div>
        <div class="hint-area" id="hintArea"></div>
      </div>
      <div class="options-area" id="optionsArea"></div>
      <div class="button-area">
        <button class="btn btn-secondary" id="hintBtn">🖼️ 그림 힌트</button>
        <button class="btn btn-primary" id="submitBtn" disabled>✅ 정답 제출</button>
        <button class="btn btn-success" id="nextBtn" style="display:none;">➡️ 다음 문제</button>
      </div>
      <div class="feedback" id="feedback"></div>
      <div class="game-over" id="gameOver">
        <div class="final-score" id="finalScore"></div>
        <button class="btn btn-primary" onclick="restartQuiz()">🔄 퀴즈 다시하기</button>
        <button class="btn btn-secondary" onclick="resetApp()">📷 새 사진 업로드</button>
      </div>
    </div>
  </div>
  <script>
    // ** 변경된 API URL 설정 (프록시 서버 사용) **
    // TODO: 아래 YOUR_WORKER_URL 부분을 실제 Cloudflare Worker 주소로 변경해주세요.
    const WORKER_URL = 'https://wordquiz.dfkimni.workers.dev/';
    const PROXY_URL = `${WORKER_URL}/api`;

    // API 호출을 위한 재시도 로직
    async function fetchWithRetry(url, options, maxRetries = 3) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            throw new Error('API 응답 실패: ' + response.statusText);
          }
          return response;
        } catch (error) {
          console.error('API 호출 실패 (재시도 중):', error);
          const delay = Math.pow(2, i) * 1000;
          await new Promise(res => setTimeout(res, delay));
        }
      }
      throw new Error('최대 재시도 횟수 초과. API 호출에 실패했습니다.');
    }

    let extractedWords = [];
    let quizQuestions = [];
    let currentQuestionIndex = 0;
    let score = 0;
    let selectedOption = null;
    let isAnswered = false;
    let hintUsed = false;
    let answerScore = 100;
    let hintImageUrl = null;

    // DOM 요소 캐싱
    const uploadArea = document.getElementById("uploadArea");
    const fileInput = document.getElementById("fileInput");
    const loading = document.getElementById("loading");
    const loadingMsg = document.getElementById("loadingMsg");
    const errorMessage = document.getElementById("errorMessage");
    const uploadScreen = document.getElementById("uploadScreen");
    const imagePreview = document.getElementById("imagePreview");
    const previewImg = document.getElementById("previewImg");
    const wordExtraction = document.getElementById("wordExtraction");
    const extractedWordsEl = document.getElementById("extractedWords");
    const wordCount = document.getElementById("wordCount");
    const startQuizBtn = document.getElementById("startQuizBtn");
    const quizGame = document.getElementById("quizGame");
    const questionType = document.getElementById("questionType");
    const questionWord = document.getElementById("questionWord");
    const hintArea = document.getElementById("hintArea");
    const optionsArea = document.getElementById("optionsArea");
    const hintBtn = document.getElementById("hintBtn");
    const submitBtn = document.getElementById("submitBtn");
    const nextBtn = document.getElementById("nextBtn");
    const feedback = document.getElementById("feedback");
    const scoreEl = document.getElementById("score");
    const currentQuestionEl = document.getElementById("currentQuestion");
    const totalQuestionsEl = document.getElementById("totalQuestions");
    const progressFill = document.getElementById("progressFill");
    const gameOver = document.getElementById("gameOver");
    const finalScore = document.getElementById("finalScore");
    const pronounceBtn = document.getElementById("pronounceBtn");

    // 업로드 이벤트
    uploadArea.addEventListener("click", () => fileInput.click());
    uploadArea.addEventListener("dragover", e => { e.preventDefault(); uploadArea.classList.add("dragover"); });
    uploadArea.addEventListener("dragleave", e => { e.preventDefault(); uploadArea.classList.remove("dragover"); });
    uploadArea.addEventListener("drop", e => { e.preventDefault(); uploadArea.classList.remove("dragover"); if (e.dataTransfer.files.length > 0) processFile(e.dataTransfer.files[0]); });
    fileInput.addEventListener("change", e => { if (e.target.files.length > 0) processFile(e.target.files[0]); });

    // 버튼 이벤트 리스너 추가
    startQuizBtn.addEventListener('click', startQuiz);
    hintBtn.addEventListener('click', showHint);
    submitBtn.addEventListener('click', submitAnswer);
    nextBtn.addEventListener('click', nextQuestion);
    pronounceBtn.addEventListener('click', pronounceWord);

    // 사진 파일 처리: OCR 실행 → 단어 추출 → Gemini API 번역 요청
    async function processFile(file) {
      if (!file.type.startsWith("image/")) {
        showError("이미지 파일만 업로드 가능합니다.");
        return;
      }
      previewImg.src = "";
      imagePreview.style.display = "none";
      loading.style.display = "block";
      errorMessage.style.display = "none";
      loadingMsg.textContent = "사진에서 영어 단어 추출 중...";
      const reader = new FileReader();
      reader.onload = e => {
        previewImg.src = e.target.result;
        imagePreview.style.display = "block";
      };
      reader.readAsDataURL(file);
      try {
        const ocrRes = await Tesseract.recognize(file, "eng", {
          logger: m => { if (m.status === "recognizing text") loadingMsg.textContent = `단어 추출 중... ${Math.round(m.progress * 100)}%`; }
        });
        const wordsRaw = ocrRes.data.words.map(w => w.text).join(' ').split(/\W+/);
        const wordsSet = new Set(wordsRaw.map(w => w.trim().toLowerCase()).filter(w => /^[a-zA-Z]{3,15}$/.test(w)));
        const words = [...wordsSet].slice(0, 20);
        if (words.length < 4) throw new Error("퀴즈를 만들 충분한 단어(최소 4개)를 찾지 못했습니다.");
        loadingMsg.textContent = "번역 중...";
        extractedWords = await translateWordsWithGemini(words);
        if (extractedWords.length < 4) throw new Error("번역 결과 이상: 퀴즈를 만들 충분한 단어가 부족합니다.");
        loading.style.display = "none";
        displayExtractedWords();
      } catch (e) {
        console.error(e);
        showError("OCR 또는 번역 중 오류가 발생했습니다: " + e.message);
        loading.style.display = "none";
      }
    }

    // Gemini API를 사용하여 영어 단어를 한국어로 번역하는 함수
    async function translateWordsWithGemini(words) {
      const chatHistory = [{
        role: "user",
        parts: [{
          text: `다음 영어 단어들을 한국어로 번역하고, 각 단어에 대해 영어 단어와 한국어 번역을 포함하는 JSON 배열을 생성해줘. JSON의 키는 'englishWord'와 'koreanTranslation'으로 해줘. JSON 형식 외에는 어떤 다른 텍스트나 설명도 추가하지 마.
          예시:
          input: ["apple", "banana"]
          output: [{"englishWord": "apple", "koreanTranslation": "사과"}, {"englishWord": "banana", "koreanTranslation": "바나나"}]
          단어 목록: [${words.map(w => `"${w}"`).join(', ')}]
          `
        }]
      }];
      const payload = {
        contents: chatHistory,
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: {
            type: "ARRAY",
            items: {
              type: "OBJECT",
              properties: {
                "englishWord": { "type": "STRING" },
                "koreanTranslation": { "type": "STRING" }
              },
              "propertyOrdering": ["englishWord", "koreanTranslation"]
            }
          }
        }
      };
      try {
        const response = await fetchWithRetry(`${PROXY_URL}/translate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (result.candidates && result.candidates.length > 0) {
          const jsonString = result.candidates[0].content.parts[0].text;
          const parsedJson = JSON.parse(jsonString);
          return parsedJson.filter(item => item.koreanTranslation);
        } else {
          return [];
        }
      } catch (e) {
        console.error("Translation API error:", e);
        throw new Error("단어 번역 중 오류가 발생했습니다.");
      }
    }

    // 추출된 단어 목록을 화면에 표시
    function displayExtractedWords() {
      uploadScreen.style.display = 'none';
      wordExtraction.style.display = 'block';
      wordCount.textContent = extractedWords.length;
      extractedWordsEl.innerHTML = '';
      extractedWords.forEach(wordPair => {
        const div = document.createElement('div');
        div.className = 'word-pair';
        div.innerHTML = `<span class="korean-word">${wordPair.koreanTranslation}</span><span class="english-word">${wordPair.englishWord}</span>`;
        extractedWordsEl.appendChild(div);
      });
    }

    // 퀴즈 시작
    function startQuiz() {
      wordExtraction.style.display = 'none';
      quizGame.style.display = 'block';
      quizQuestions = shuffleArray([...extractedWords]); // 단어 목록을 섞어서 퀴즈 문제로 사용
      currentQuestionIndex = 0;
      score = 0;
      updateScoreBoard();
      updateProgressBar();
      showQuestion();
    }

    // 퀴즈 다시 시작
    function restartQuiz() {
      gameOver.style.display = 'none';
      startQuiz();
    }

    // 퀴즈 문제 표시
    function showQuestion() {
      // 상태 초기화
      selectedOption = null;
      isAnswered = false;
      hintUsed = false;
      answerScore = 100;
      hintImageUrl = null;
      feedback.style.display = 'none';
      hintArea.innerHTML = '';
      submitBtn.style.display = 'inline-block';
      submitBtn.disabled = true;
      nextBtn.style.display = 'none';
      hintBtn.disabled = false;

      if (currentQuestionIndex >= quizQuestions.length) {
        // 모든 문제 풀이 완료
        endQuiz();
        return;
      }

      const question = quizQuestions[currentQuestionIndex];
      questionWord.textContent = question.englishWord;
      updateScoreBoard();

      // 객관식 옵션 생성
      createOptions(question);
    }

    // 객관식 옵션 생성
    function createOptions(question) {
      optionsArea.innerHTML = '';
      const allWords = [...extractedWords];
      // 정답을 제외한 다른 단어들을 후보로 사용
      const incorrectOptions = allWords.filter(item => item.englishWord !== question.englishWord);
      const shuffledIncorrect = shuffleArray(incorrectOptions);
      // 정답 + 오답 3개
      const options = [
        question.koreanTranslation,
        shuffledIncorrect[0].koreanTranslation,
        shuffledIncorrect[1].koreanTranslation,
        shuffledIncorrect[2].koreanTranslation
      ];
      const shuffledOptions = shuffleArray(options);

      shuffledOptions.forEach(optionText => {
        const option = document.createElement('div');
        option.className = 'option';
        option.textContent = optionText;
        option.addEventListener('click', () => handleOptionClick(option, optionText));
        optionsArea.appendChild(option);
      });
    }

    // 옵션 클릭 핸들러
    function handleOptionClick(optionEl, optionText) {
      if (isAnswered) return;
      // 이전에 선택된 옵션 스타일 초기화
      document.querySelectorAll('.option').forEach(el => el.classList.remove('selected'));
      // 현재 선택된 옵션 스타일 적용
      optionEl.classList.add('selected');
      selectedOption = optionText;
      submitBtn.disabled = false;
    }

    // 정답 제출
    function submitAnswer() {
      if (!selectedOption || isAnswered) return;
      isAnswered = true;
      submitBtn.disabled = true;
      nextBtn.style.display = 'inline-block';
      hintBtn.disabled = true;

      const question = quizQuestions[currentQuestionIndex];
      const correctOption = question.koreanTranslation;

      document.querySelectorAll('.option').forEach(el => {
        el.classList.add('disabled');
        if (el.textContent === correctOption) {
          el.classList.add('correct');
        } else if (el.textContent === selectedOption) {
          el.classList.add('incorrect');
        }
      });

      if (selectedOption === correctOption) {
        feedback.textContent = `✅ 정답입니다! (+${answerScore}점)`;
        feedback.className = 'feedback correct';
        score += answerScore;
      } else {
        feedback.textContent = `❌ 오답입니다. 정답은 '${correctOption}' 이었어요.`;
        feedback.className = 'feedback incorrect';
        score = Math.max(0, score - 50); // 오답 시 감점
      }
      feedback.style.display = 'block';
      updateScoreBoard();
    }

    // 다음 문제로 이동
    function nextQuestion() {
      currentQuestionIndex++;
      updateProgressBar();
      showQuestion();
    }

    // 퀴즈 종료
    function endQuiz() {
      quizGame.style.display = 'none';
      gameOver.style.display = 'block';
      finalScore.textContent = `최종 점수: ${score}점`;
    }

    // 그림 힌트 제공
    async function showHint() {
      if (hintUsed) return;
      hintUsed = true;
      answerScore -= 30; // 힌트 사용 시 감점
      hintBtn.disabled = true;

      const question = quizQuestions[currentQuestionIndex];
      hintArea.innerHTML = `<div class="hint-loading"></div>`;

      try {
        const payload = {
          instances: {
            prompt: `a line art drawing of "${question.englishWord}"`
          },
          parameters: { "sampleCount": 1 }
        };
        const response = await fetchWithRetry(`${PROXY_URL}/image`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
          hintImageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
          hintArea.innerHTML = `<img src="${hintImageUrl}" alt="그림 힌트" class="hint-image" />`;
        } else {
          hintArea.innerHTML = `<div class="text-hint">그림 힌트를 생성할 수 없습니다.</div>`;
        }
      } catch (e) {
        console.error("Image API error:", e);
        hintArea.innerHTML = `<div class="text-hint">그림 힌트 생성 중 오류 발생</div>`;
      }
    }

    // 단어 발음 듣기
    async function pronounceWord() {
      const question = quizQuestions[currentQuestionIndex];
      const audioBtn = pronounceBtn;
      audioBtn.disabled = true;
      audioBtn.innerHTML = '🎧';

      try {
        const payload = {
          contents: [{
            parts: [{ text: `Say in an even tone: ${question.englishWord}` }]
          }],
          generationConfig: {
            responseModalities: ["AUDIO"],
            speechConfig: {
              voiceConfig: {
                prebuiltVoiceConfig: { voiceName: "Iapetus" }
              }
            }
          },
          model: "gemini-2.5-flash-preview-tts"
        };
        const response = await fetchWithRetry(`${PROXY_URL}/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        const part = result?.candidates?.[0]?.content?.parts?.[0];
        const audioData = part?.inlineData?.data;
        const mimeType = part?.inlineData?.mimeType;

        if (audioData && mimeType && mimeType.startsWith("audio/")) {
          const sampleRate = 24000;
          const pcmData = base64ToArrayBuffer(audioData);
          const pcm16 = new Int16Array(pcmData);
          const wavBlob = pcmToWav(pcm16, sampleRate);
          const audioUrl = URL.createObjectURL(wavBlob);
          const audio = new Audio(audioUrl);
          audio.play();
        } else {
          console.error("TTS API 응답 오류");
        }
      } catch (e) {
        console.error("TTS API error:", e);
      } finally {
        audioBtn.disabled = false;
        audioBtn.innerHTML = '🔊';
      }
    }

    // 스코어보드 업데이트
    function updateScoreBoard() {
      currentQuestionEl.textContent = currentQuestionIndex + 1;
      totalQuestionsEl.textContent = quizQuestions.length;
      scoreEl.textContent = score;
    }

    // 진행 바 업데이트
    function updateProgressBar() {
      const progress = ((currentQuestionIndex + 1) / quizQuestions.length) * 100;
      progressFill.style.width = `${progress}%`;
    }

    // 전체 앱 초기화
    function resetApp() {
      location.reload();
    }

    // 에러 메시지 표시
    function showError(msg) {
      errorMessage.textContent = msg;
      errorMessage.style.display = 'block';
    }

    // 배열 섞기 (Fisher-Yates 알고리즘)
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Base64 문자열을 ArrayBuffer로 변환
    function base64ToArrayBuffer(base64) {
      const binaryString = window.atob(base64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    // PCM 오디오 데이터를 WAV Blob으로 변환
    function pcmToWav(pcm16, sampleRate) {
      const numChannels = 1;
      const bitDepth = 16;
      const buffer = new ArrayBuffer(44 + pcm16.length * 2);
      const view = new DataView(buffer);

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      // RIFF identifier
      writeString(view, 0, 'RIFF');
      // RIFF chunk length
      view.setUint32(4, 36 + pcm16.length * 2, true);
      // RIFF type
      writeString(view, 8, 'WAVE');
      // format chunk identifier
      writeString(view, 12, 'fmt ');
      // format chunk length
      view.setUint32(16, 16, true);
      // sample format (1 = PCM)
      view.setUint16(20, 1, true);
      // number of channels
      view.setUint16(22, numChannels, true);
      // sample rate
      view.setUint32(24, sampleRate, true);
      // byte rate
      view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
      // block align
      view.setUint16(32, numChannels * (bitDepth / 8), true);
      // bits per sample
      view.setUint16(34, bitDepth, true);
      // data chunk identifier
      writeString(view, 36, 'data');
      // data chunk length
      view.setUint32(40, pcm16.length * 2, true);

      // PCM audio data
      let offset = 44;
      for (let i = 0; i < pcm16.length; i++, offset += 2) {
        view.setInt16(offset, pcm16[i], true);
      }

      return new Blob([view], { type: 'audio/wav' });
    }
  </script>
</body>
</html>
